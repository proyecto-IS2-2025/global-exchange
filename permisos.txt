Informe Técnico: Sistema de Gestión de Permisos y Roles
1. CONTEXTO Y ORGANIZACIÓN DEL PROYECTO
1.1 Estructura Actual del Proyecto
Basándome en la imagen proporcionada y los archivos analizados, el proyecto tiene la siguiente organización:
casa_de_cambios/
├── autenticacion/          # Login, registro, verificación de email
├── banco/                  # Gestión de cuentas bancarias
├── billetera/              # Sistema de billeteras virtuales
├── casa_de_cambios/        # Configuración principal (settings, urls)
├── clientes/               # Gestión de clientes y asignaciones
├── divisas/                # Operaciones de compra/venta de divisas
├── interfaz/               # Templates y vistas públicas
├── medios_pago/            # Configuración de medios de pago
├── permisos/               # (App vacía, sin implementar)
├── roles/                  # Gestión de grupos y permisos
├── simulador/              # Simulador de operaciones
├── transacciones/          # Registro de transacciones
└── users/                  # Modelo de usuario personalizado
1.2 Módulos Principales del Sistema
Módulos Operativos:

clientes: CRUD de clientes, asignación a operadores, gestión de descuentos, límites, medios de pago
divisas: Operaciones de compra/venta, tasas de cambio, cotizaciones por segmento
transacciones: Registro y consulta de operaciones realizadas
medios_pago: Definición de tipos de medios de pago con campos dinámicos
banco/billetera: Gestión de fondos

Módulos Administrativos:

users: Gestión de usuarios (CustomUser)
roles: Gestión de grupos (roles) y permisos
autenticacion: Login, registro, verificación

Módulos de Interfaz:

interfaz: Vistas públicas, dashboard, redirección por rol
simulador: Simulación de operaciones

2. PROBLEMA ACTUAL: SISTEMA DE PERMISOS FRAGMENTADO
2.1 Estado Actual de Autenticación y Autorización
El sistema actual utiliza tres mecanismos inconsistentes para controlar acceso:
Mecanismo 1: Verificación de Grupos en Templates (Frontend)
python# interfaz/views.py
grupo_cliente = request.user.groups.filter(name="cliente").exists()
grupo_operador = request.user.groups.filter(name="operador").exists()
grupo_admin = request.user.groups.filter(name="admin").exists()
Problemas:

Verificación solo en frontend, vulnerable a manipulación
Lógica duplicada en múltiples vistas
No hay control granular de acciones específicas

Mecanismo 2: Decoradores Básicos
python# Usado en clientes/views.py
@login_required
@user_passes_test(lambda u: u.is_staff)
def crear_limite_diario(request):
    ...

# Usado en roles/views.py
@user_passes_test(is_admin)
def group_create(request):
    ...
Problemas:

Criterios arbitrarios (is_staff, is_admin)
No hay estandarización
Difícil auditar quién puede hacer qué

Mecanismo 3: Mixins en CBV (Parcialmente Implementado)
python# clientes/views.py
class ClienteListView(LoginRequiredMixin, PermissionRequiredMixin, ListView):
    permission_required = "clientes.view_cliente"  # ← Permiso que NO existe
Problema crítico: Los permisos están comentados en el modelo:
python# clientes/models.py
class Cliente(models.Model):
    class Meta:
        #permissions = [
        #    ("view_cliente", "Puede ver clientes"),
        #]
Esto significa que permission_required = "clientes.view_cliente" NO funciona, pero el código no falla porque Django permite verificar permisos inexistentes (siempre retorna False).
2.2 Grupos Actuales del Sistema
Según el código analizado:

admin: Acceso total (verificado con is_staff o is_superuser)
operador/cambista: Realiza operaciones para clientes asignados
cliente: Usuario final con acceso limitado
usuario_registrado: Usuario sin clientes asignados

Problema: No hay diferenciación entre:

Administrador que configura el sistema
Supervisor que solo consulta
Analista que genera reportes
Operador senior vs. operador junior

2.3 Conflictos Identificados
Conflicto 1: Middleware vs. Permisos
El ClienteActivoMiddleware gestiona la selección de cliente activo:
python# clientes/middleware.py
if total == 1:
    cliente = asign_qs.first().cliente
    request.session['cliente_activo_id'] = cliente.id
elif total > 1:
    return redirect(f"{self.selector_path}?next={next_url}")
Problema: Un operador puede tener cliente activo en sesión, pero el sistema NO verifica si tiene permisos para realizar acciones sobre ese cliente específico.
Escenario vulnerable:

Operador Juan tiene clientes A y B asignados
Sesión tiene cliente_activo_id = A
Juan manipula URL para acceder a /clientes/C/editar/
Si la vista solo verifica @login_required, Juan accede a cliente no asignado

Conflicto 2: Verificación de Contexto Inexistente
Muchas vistas dependen del cliente activo pero NO verifican permisos sobre él:
python# clientes/views.py
def get_cliente_activo(request):
    cliente_id = request.session.get('cliente_activo_id')
    return Cliente.objects.get(id=cliente_id)  # Sin verificar permisos
Conflicto 3: Permisos Genéricos vs. Necesidades Específicas
Django ofrece permisos genéricos:

add_cliente, change_cliente, delete_cliente, view_cliente

Pero el sistema necesita:

Ver solo clientes asignados vs. ver todos
Modificar datos básicos vs. modificar límites
Exportar datos (acción que no es CRUD)

Conflicto 4: Redirección por Grupo Hardcodeada
python# interfaz/views.py
def redireccion_por_grupo(request):
    if 'admin' in grupos:
        return redirect('admin_dashboard')
    elif 'operador' in grupos:
        return redirect('cambista_dashboard')
Agregar nuevo rol requiere modificar esta función.
3. SOLUCIÓN PROPUESTA: SISTEMA DE PERMISOS EN 3 CAPAS
3.1 Arquitectura General
┌────────────────────────────────────────────────────────────┐
│ CAPA 1: DEFINICIÓN DE PERMISOS                            │
│ Desarrollador define permisos al crear funcionalidad       │
│ Archivo: roles/management/commands/permissions_defs/       │
└────────────────────────────────────────────────────────────┘
                            ↓
┌────────────────────────────────────────────────────────────┐
│ CAPA 2: ASIGNACIÓN DINÁMICA                               │
│ Admin asigna permisos a roles desde interfaz web           │
│ Interfaz: /roles/groups/<id>/permissions/                  │
└────────────────────────────────────────────────────────────┘
                            ↓
┌────────────────────────────────────────────────────────────┐
│ CAPA 3: VERIFICACIÓN AUTOMÁTICA                           │
│ Sistema verifica permisos en cada petición                 │
│ Componente: Decoradores/Mixins centralizados               │
└────────────────────────────────────────────────────────────┘
3.2 Componentes del Nuevo Sistema
Componente A: Modelo Extendido de Permisos
python# roles/models.py (NUEVO)
class PermissionMetadata(models.Model):
    """Extiende Permission con metadata para admin"""
    permission = models.OneToOneField(Permission, on_delete=models.CASCADE)
    modulo = models.CharField(max_length=50, choices=MODULOS_CHOICES)
    descripcion_detallada = models.TextField()
    ejemplo_uso = models.TextField()
    nivel_riesgo = models.CharField(max_length=20, choices=RIESGO_CHOICES)
    orden = models.IntegerField(default=0)
Beneficio: Admin ve qué hace cada permiso sin leer código.
Componente B: Registro de Permisos por Módulo
python# roles/management/commands/permissions_defs/
├── __init__.py
├── clientes.py       # Permisos de módulo clientes
├── divisas.py        # Permisos de módulo divisas
├── medios_pago.py    # Permisos de módulo medios_pago
└── transacciones.py  # Permisos de módulo transacciones
Estructura de cada archivo:
python# roles/management/commands/permissions_defs/clientes.py
PERMISOS_CLIENTES = [
    {
        'app_label': 'clientes',
        'model': 'cliente',
        'codename': 'view_assigned_clientes',
        'name': 'Puede ver clientes asignados',
        'modulo': 'clientes',
        'descripcion': 'Permite ver únicamente los clientes asignados al usuario',
        'ejemplo': 'Un operador ve solo sus 5 clientes asignados',
        'nivel_riesgo': 'bajo',
        'orden': 1,
    },
    # ... más permisos
]
Beneficio: Cada desarrollador trabaja en su archivo, menos conflictos Git.
Componente C: Comando de Sincronización
python# roles/management/commands/sync_permissions.py
class Command(BaseCommand):
    def handle(self):
        permisos = (
            PERMISOS_CLIENTES +
            PERMISOS_DIVISAS +
            PERMISOS_MEDIOS_PAGO +
            PERMISOS_TRANSACCIONES
        )
        
        for perm_def in permisos:
            # Crear Permission en BD
            # Crear PermissionMetadata asociado
Ejecución: python manage.py sync_permissions
Componente D: Interfaz de Admin Mejorada
python# roles/views.py (MODIFICADO)
@user_passes_test(is_admin)
def group_manage_permissions(request, pk):
    """Vista con permisos agrupados por módulo"""
    
    # Obtener permisos categorizados
    permisos_por_modulo = {}
    for permiso in Permission.objects.select_related('metadata'):
        modulo = permiso.metadata.modulo
        if modulo not in permisos_por_modulo:
            permisos_por_modulo[modulo] = []
        permisos_por_modulo[modulo].append(permiso)
    
    # Template muestra pestañas por módulo
Template con pestañas:
html<!-- roles/templates/groups/manage_permissions.html -->
<ul class="nav nav-tabs">
    <li><a href="#clientes">Clientes (12)</a></li>
    <li><a href="#divisas">Divisas (8)</a></li>
    <li><a href="#medios_pago">Medios de Pago (5)</a></li>
</ul>
Componente E: Decoradores Centralizados
python# clientes/decorators.py (NUEVO)
from functools import wraps
from django.core.exceptions import PermissionDenied

def require_permission(permission, check_client_assignment=True):
    """
    Decorador que verifica:
    1. Permiso base
    2. Contexto de cliente (si aplica)
    """
    def decorator(view_func):
        @wraps(view_func)
        def wrapper(request, *args, **kwargs):
            # Verificar permiso
            if not request.user.has_perm(permission):
                raise PermissionDenied
            
            # Verificar contexto si es necesario
            if check_client_assignment:
                cliente = get_cliente_activo(request)
                if not tiene_acceso_a_cliente(request.user, cliente):
                    raise PermissionDenied
            
            return view_func(request, *args, **kwargs)
        return wrapper
    return decorator
Uso en vistas:
python# clientes/views.py (MODIFICADO)
@login_required
@require_permission('clientes.manage_medios_pago')
def agregar_medio_pago(request):
    # Solo usuarios con el permiso pueden acceder
    ...
Componente F: Managers con Filtrado Contextual
python# clientes/managers.py (NUEVO)
class ClienteAccessManager(models.Manager):
    def for_user(self, user):
        """Retorna solo clientes que el usuario puede ver"""
        if user.has_perm('clientes.view_all_clientes'):
            return self.get_queryset()
        else:
            return self.get_queryset().filter(
                asignacioncliente__usuario=user
            )
Uso:
python# clientes/views.py
clientes = Cliente.objects.for_user(request.user)  # Filtrado automático
4. ARCHIVOS A MODIFICAR Y AGREGAR
4.1 Archivos NUEVOS a crear
roles/
├── management/
│   └── commands/
│       ├── sync_permissions.py          [NUEVO]
│       ├── setup_test_roles.py          [NUEVO]
│       ├── show_permission_matrix.py    [NUEVO]
│       └── permissions_defs/            [NUEVA CARPETA]
│           ├── __init__.py
│           ├── clientes.py
│           ├── divisas.py
│           ├── medios_pago.py
│           ├── transacciones.py
│           └── usuarios.py
├── models.py                            [MODIFICAR - agregar PermissionMetadata]
├── views.py                             [MODIFICAR - mejorar group_manage_permissions]
└── templates/
    └── groups/
        └── manage_permissions.html      [MODIFICAR - agregar pestañas]

clientes/
├── decorators.py                        [NUEVO]
├── managers.py                          [NUEVO]
├── models.py                            [MODIFICAR - descomentar permisos]
└── views.py                             [MODIFICAR - agregar decoradores]

divisas/
├── decorators.py                        [NUEVO - si necesita lógica específica]
└── views.py                             [MODIFICAR - agregar verificaciones]

casa_de_cambios/
└── settings.py                          [MODIFICAR - agregar configuración]
4.2 Migraciones Necesarias
bash# Crear modelo PermissionMetadata
python manage.py makemigrations roles

# Aplicar migración
python manage.py migrate roles

# Sincronizar permisos
python manage.py sync_permissions

# Setup roles de prueba (solo en desarrollo)
python manage.py setup_test_roles
5. APPS AFECTADAS Y SU IMPACTO
5.1 App: roles (Modificación ALTA)
Estado actual: Gestión básica de grupos y búsqueda de permisos.
Cambios:

Agregar modelo PermissionMetadata
Mejorar vista group_manage_permissions con categorización
Crear comandos de management
Agregar template con pestañas por módulo

Impacto: Esta es la app central del nuevo sistema. Requiere refactorización significativa pero controlada.
5.2 App: clientes (Modificación MEDIA)
Estado actual: Usa verificaciones mixtas (@user_passes_test, PermissionRequiredMixin con permisos inexistentes).
Cambios:

Descomentar y expandir permisos en Meta
Crear decorators.py con verificadores contextuales
Crear managers.py para filtrado
Reemplazar gradualmente verificaciones antiguas

Impacto: Es la app más compleja (40+ vistas). Migración gradual recomendada.
5.3 App: divisas (Modificación MEDIA)
Estado actual: Usa @login_required principalmente.
Cambios:

Definir permisos específicos (realizar_operaciones, configure_tasas)
Agregar decoradores a vistas
Verificar límites en combinación con permisos

Impacto: Moderado, pero crítico porque maneja operaciones financieras.
5.4 App: users (Modificación BAJA)
Estado actual: CRUD de usuarios con verificaciones básicas.
Cambios:

Definir permisos (manage_operators, view_user_profiles)
Agregar verificaciones en vistas de gestión

Impacto: Bajo, pocas vistas afectadas.
5.5 App: transacciones (Modificación BAJA)
Estado actual: Principalmente consulta de datos.
Cambios:

Definir permisos (view_transacciones, export_reportes, approve_transactions)
Filtrado contextual (solo transacciones de clientes asignados)

Impacto: Bajo, la mayoría son vistas de solo lectura.
5.6 App: interfaz (Modificación BAJA)
Estado actual: Vistas públicas y redirección hardcodeada.
Cambios:

Modificar redireccion_por_grupo para leer configuración
Agregar context processor para menú dinámico

Impacto: Cambios pequeños pero importantes para UX.
5.7 App: medios_pago (Modificación BAJA)
Estado actual: Configuración de tipos de medios de pago.
Cambios:

Definir permisos (configure_payment_methods)
Solo admin puede configurar

Impacto: Muy bajo, pocas vistas administrativas.
6. FLUJO DE TRABAJO PARA DESARROLLADORES
6.1 Escenario: Agregar Nueva Funcionalidad
Ejemplo: Implementar "Aprobar Transacciones de Alto Monto"
PASO 1: Implementar Funcionalidad (código normal)
python# transacciones/views.py
from django.shortcuts import render, get_object_or_404
from .models import Transaccion

def aprobar_transaccion(request, transaccion_id):
    """Vista para aprobar transacción pendiente"""
    transaccion = get_object_or_404(Transaccion, id=transaccion_id)
    
    if request.method == 'POST':
        transaccion.estado = 'APROBADA'
        transaccion.aprobado_por = request.user
        transaccion.save()
        messages.success(request, 'Transacción aprobada')
        return redirect('transacciones:pendientes')
    
    return render(request, 'transacciones/aprobar.html', {
        'transaccion': transaccion
    })
python# transacciones/urls.py
urlpatterns = [
    path('<int:transaccion_id>/aprobar/', aprobar_transaccion, name='aprobar'),
]
PASO 2: Definir Permiso
Archivo a modificar: roles/management/commands/permissions_defs/transacciones.py
python# roles/management/commands/permissions_defs/transacciones.py
PERMISOS_TRANSACCIONES = [
    # ... permisos existentes ...
    
    # NUEVO PERMISO AGREGADO
    {
        'app_label': 'transacciones',
        'model': 'transaccion',
        'codename': 'approve_high_amount_transactions',
        'name': 'Puede aprobar transacciones de alto monto',
        'modulo': 'transacciones',
        'descripcion': 'Permite aprobar o rechazar transacciones superiores al límite estándar',
        'ejemplo': 'Un supervisor puede aprobar una transacción de $10,000 USD',
        'nivel_riesgo': 'alto',
        'orden': 3,
    },
]
Convención de nombres de permisos:

view_*: Solo lectura
manage_*: Crear/editar/eliminar
approve_*: Aprobaciones
export_*: Exportar datos
configure_*: Configuración del sistema

PASO 3: Aplicar Decorador
python# transacciones/views.py (MODIFICADO)
from clientes.decorators import require_permission

@login_required
@require_permission('transacciones.approve_high_amount_transactions', check_client_assignment=False)
def aprobar_transaccion(request, transaccion_id):
    # Mismo código que antes
    ...
Nota: check_client_assignment=False porque la aprobación no depende de cliente activo.
PASO 4: Sincronizar Permisos
bashpython manage.py sync_permissions
Salida esperada:
✓ Creado: Puede aprobar transacciones de alto monto
✓ Sincronización completa: 1 creados, 47 actualizados
PASO 5: Testing con Rol QA
bash# Asegurarse que existe rol QA
python manage.py setup_test_roles

# Iniciar sesión con usuario qa@test.com
# Probar funcionalidad completa
PASO 6: Commit y Push
bashgit add roles/management/commands/permissions_defs/transacciones.py
git add transacciones/views.py
git add transacciones/urls.py
git commit -m "feat: agregar aprobación de transacciones de alto monto"
git push origin feature/aprobar-transacciones
PASO 7: Deploy y Notificación al Admin
Después del deploy a producción:

Ejecutar migración (si hubo cambios en modelos)
Ejecutar python manage.py sync_permissions
Notificar al administrador:

Email/Slack al admin:
Nuevas funcionalidades disponibles:

Módulo: Transacciones
- "Puede aprobar transacciones de alto monto"
  
Acciones requeridas:
1. Ingrese a /roles/groups/
2. Edite el rol "supervisor"
3. Pestaña "Transacciones" → marque el nuevo permiso
4. Guarde cambios

Documentación: docs/permisos/aprobar-transacciones.md
PASO 8: Admin Asigna Permiso

Admin ingresa al sistema
Va a /roles/groups/
Selecciona rol "supervisor"
Pestaña "Transacciones"
Ve nuevo permiso con descripción y ejemplo
Marca checkbox
Guarda

A partir de este momento: Los usuarios con rol "supervisor" pueden aprobar transacciones.
6.2 Checklist para Desarrolladores
Al agregar nueva funcionalidad:
□ 1. Implementar vista/lógica
□ 2. Agregar definición de permiso en permissions_defs/<modulo>.py
□ 3. Aplicar decorador @require_permission
□ 4. Ejecutar sync_permissions localmente
□ 5. Probar con usuario QA
□ 6. Commit con mensaje descriptivo
□ 7. Documentar en README o docs/
□ 8. Notificar al admin después del deploy
6.3 Resolución de Conflictos Git
Si dos desarrolladores modifican el mismo archivo de permisos:
python# Dev A agrega:
{
    'codename': 'export_excel_reports',
    ...
},

# Dev B agrega en la misma posición:
{
    'codename': 'approve_high_amount_transactions',
    ...
},
Resolución: Mantener ambos, solo ajustar orden:
python{
    'codename': 'export_excel_reports',
    'orden': 3,
},
{
    'codename': 'approve_high_amount_transactions',
    'orden': 4,  # Ajustar orden si es necesario
},
6.4 Matriz de Responsabilidades
RolTareaFrecuenciaDesarrolladorDefinir permisos nuevosPor featureDesarrolladorAplicar decoradoresPor featureDesarrolladorEjecutar sync_permissions (dev)Por featureDevOpsEjecutar sync_permissions (prod)En cada deployAdminAsignar permisos a rolesPor featureQAProbar con diferentes rolesPor featureAdminAuditar matriz de permisosMensual
7. BENEFICIOS DEL NUEVO SISTEMA
7.1 Para Desarrolladores

Un solo lugar donde definir permisos
Decoradores reutilizables
Menos código duplicado
Testing más fácil con rol QA

7.2 Para Administradores

Control total desde interfaz web
Descripción clara de cada permiso
No necesita tocar código
Auditoría visual de permisos por rol

7.3 Para el Sistema

Seguridad reforzada (verificación backend)
Escalable (agregar permisos no rompe nada)
Auditable (logs de cambios)
Mantenible (código centralizado)

8. RIESGOS Y MITIGACIONES
RiesgoProbabilidadImpactoMitigaciónMigración rompe funcionalidad existenteMediaAltoMigración gradual, mantener sistema antiguo en paraleloConflictos Git en permissions_defsMediaBajoEstructura modular por appAdmin asigna permisos incorrectosMediaMedioNiveles de riesgo visibles, confirmación antes de guardarPerformance con muchos permisosBajaMedioCaché de permisos, prefetch en queries

Este informe constituye la base técnica para la implementación del nuevo sistema de permisos. La migración debe realizarse de forma incremental, comenzando por el módulo menos crítico (ej: simulador) y avanzando hacia módulos críticos (divisas, transacciones) una vez validado el funcionamiento.


ASPECTOS A CONSIDERAR DEL ANALISIS

Gestión de Permisos Dinámico desde Interfaz de Admin
1. Análisis de lo que YA TIENES implementado
Revisando roles/views.py y roles/templates/, ya tienes:
python# roles/views.py - YA EXISTE
def group_detail_permissions(request, pk):
    """Vista que permite asignar permisos a un grupo"""
    group = get_object_or_404(Group, pk=pk)
    
    if request.method == 'POST':
        selected_permission_ids = request.POST.getlist('permissions')
        group.permissions.set(selected_permission_ids)  # ← ESTO YA FUNCIONA
Conclusión: Ya tienes la infraestructura básica para que el admin gestione permisos desde la UI. El problema es que:

Los permisos personalizados NO existen en la BD (están comentados)
No hay una interfaz amigable para ver QUÉ hace cada permiso
Falta categorización de permisos por módulo/funcionalidad

2. Sistema Completo: Gestión Dinámica de Permisos
Arquitectura de 3 Componentes
┌──────────────────────────────────────────────────┐
│  COMPONENTE 1: Definición de Permisos (Código)  │
│  Define QUÉ permisos existen y QUÉ controlan     │
│  (Solo se toca al agregar nueva funcionalidad)   │
└──────────────────────────────────────────────────┘
                        ↓
┌──────────────────────────────────────────────────┐
│  COMPONENTE 2: Asignación (BD + Admin UI)       │
│  Admin decide QUIÉN tiene CUÁLES permisos        │
│  (100% dinámico, sin tocar código)               │
└──────────────────────────────────────────────────┘
                        ↓
┌──────────────────────────────────────────────────┐
│  COMPONENTE 3: Verificación (Código)            │
│  Valida permisos en runtime automáticamente      │
└──────────────────────────────────────────────────┘
Componente 1: Modelo Extendido para Permisos
El problema con Permission de Django es que solo tiene codename y name. Necesitas más metadata para que el admin entienda qué hace cada permiso.
python# roles/models.py
from django.contrib.auth.models import Permission
from django.db import models

class PermissionMetadata(models.Model):
    """
    Extiende Permission con información útil para el admin
    """
    permission = models.OneToOneField(
        Permission,
        on_delete=models.CASCADE,
        related_name='metadata'
    )
    
    # Categorización
    modulo = models.CharField(
        max_length=50,
        choices=[
            ('clientes', 'Gestión de Clientes'),
            ('divisas', 'Operaciones de Divisas'),
            ('medios_pago', 'Medios de Pago'),
            ('transacciones', 'Transacciones'),
            ('usuarios', 'Gestión de Usuarios'),
            ('reportes', 'Reportes y Exportaciones'),
            ('configuracion', 'Configuración del Sistema'),
        ],
        help_text="Módulo al que pertenece este permiso"
    )
    
    # Información para el admin
    descripcion_detallada = models.TextField(
        help_text="Explicación detallada de qué permite hacer este permiso"
    )
    
    ejemplo_uso = models.TextField(
        blank=True,
        help_text="Ejemplo concreto: 'Permite al operador crear medios de pago para sus clientes asignados'"
    )
    
    # Nivel de peligrosidad (para advertencias en UI)
    nivel_riesgo = models.CharField(
        max_length=20,
        choices=[
            ('bajo', 'Bajo - Solo lectura'),
            ('medio', 'Medio - Modificación de datos'),
            ('alto', 'Alto - Operaciones críticas'),
            ('critico', 'Crítico - Administración del sistema'),
        ],
        default='medio'
    )
    
    # Orden para mostrar en UI
    orden = models.IntegerField(default=0)
    
    # Fecha de creación (para saber cuándo se agregó funcionalidad)
    fecha_creacion = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        ordering = ['modulo', 'orden', 'permission__name']
        verbose_name = 'Metadata de Permiso'
        verbose_name_plural = 'Metadata de Permisos'
    
    def __str__(self):
        return f"{self.permission.name} ({self.modulo})"
Componente 2: Interfaz de Admin Mejorada
Vista Principal: Gestión de Roles con Permisos Categorizados
python# roles/views.py
from django.db.models import Prefetch

@user_passes_test(is_admin)
def group_manage_permissions(request, pk):
    """
    Vista mejorada para gestionar permisos de un grupo con categorización
    """
    group = get_object_or_404(Group, pk=pk)
    
    if request.method == 'POST':
        selected_permission_ids = request.POST.getlist('permissions')
        group.permissions.set(selected_permission_ids)
        
        # Log de auditoría
        PermissionChangeLog.objects.create(
            grupo=group,
            usuario=request.user,
            permisos_agregados=selected_permission_ids,
            accion='update'
        )
        
        messages.success(request, f'Permisos del rol "{group.name}" actualizados correctamente.')
        return redirect('group_manage_permissions', pk=group.pk)
    
    # Obtener permisos agrupados por módulo
    permisos_por_modulo = {}
    
    # Obtener todos los permisos con metadata
    permisos_con_metadata = Permission.objects.select_related(
        'metadata'
    ).prefetch_related(
        'content_type'
    ).filter(
        metadata__isnull=False  # Solo mostrar permisos con metadata
    ).order_by('metadata__modulo', 'metadata__orden')
    
    for permiso in permisos_con_metadata:
        modulo = permiso.metadata.modulo
        if modulo not in permisos_por_modulo:
            permisos_por_modulo[modulo] = {
                'nombre': permiso.metadata.get_modulo_display(),
                'permisos': []
            }
        
        permisos_por_modulo[modulo]['permisos'].append({
            'id': permiso.id,
            'nombre': permiso.name,
            'codename': permiso.codename,
            'descripcion': permiso.metadata.descripcion_detallada,
            'ejemplo': permiso.metadata.ejemplo_uso,
            'nivel_riesgo': permiso.metadata.nivel_riesgo,
            'seleccionado': permiso in group.permissions.all()
        })
    
    # Permisos actuales del grupo
    permisos_actuales = group.permissions.all()
    
    context = {
        'group': group,
        'permisos_por_modulo': permisos_por_modulo,
        'permisos_actuales': permisos_actuales,
        'total_permisos': permisos_con_metadata.count(),
        'total_asignados': permisos_actuales.count(),
    }
    
    return render(request, 'groups/manage_permissions.html', context)
Template Mejorado con Categorización
html<!-- roles/templates/groups/manage_permissions.html -->
{% extends 'base.html' %}

{% block content %}
<div class="container mt-4">
    <div class="row">
        <div class="col-md-12">
            <h2>Gestionar Permisos: {{ group.name }}</h2>
            <p class="text-muted">
                Seleccione los permisos que desea asignar a este rol. 
                Los usuarios con este rol tendrán acceso a las funcionalidades seleccionadas.
            </p>
            
            <div class="alert alert-info">
                <strong>Permisos actuales:</strong> {{ total_asignados }} de {{ total_permisos }}
            </div>
        </div>
    </div>
    
    <form method="post">
        {% csrf_token %}
        
        <!-- Pestañas por módulo -->
        <ul class="nav nav-tabs" role="tablist">
            {% for modulo_key, modulo_data in permisos_por_modulo.items %}
                <li class="nav-item">
                    <a class="nav-link {% if forloop.first %}active{% endif %}" 
                       data-bs-toggle="tab" 
                       href="#modulo-{{ modulo_key }}"
                       role="tab">
                        {{ modulo_data.nombre }}
                        <span class="badge bg-secondary">
                            {{ modulo_data.permisos|length }}
                        </span>
                    </a>
                </li>
            {% endfor %}
        </ul>
        
        <!-- Contenido de pestañas -->
        <div class="tab-content border p-4">
            {% for modulo_key, modulo_data in permisos_por_modulo.items %}
                <div class="tab-pane fade {% if forloop.first %}show active{% endif %}" 
                     id="modulo-{{ modulo_key }}" 
                     role="tabpanel">
                    
                    <h4>{{ modulo_data.nombre }}</h4>
                    <hr>
                    
                    <!-- Seleccionar/Deseleccionar todos del módulo -->
                    <div class="mb-3">
                        <button type="button" 
                                class="btn btn-sm btn-outline-primary select-all-module"
                                data-module="{{ modulo_key }}">
                            Seleccionar todos
                        </button>
                        <button type="button" 
                                class="btn btn-sm btn-outline-secondary deselect-all-module"
                                data-module="{{ modulo_key }}">
                            Deseleccionar todos
                        </button>
                    </div>
                    
                    <!-- Lista de permisos del módulo -->
                    <div class="row">
                        {% for permiso in modulo_data.permisos %}
                            <div class="col-md-6 mb-3">
                                <div class="card permission-card {% if permiso.nivel_riesgo == 'critico' %}border-danger{% elif permiso.nivel_riesgo == 'alto' %}border-warning{% endif %}">
                                    <div class="card-body">
                                        <!-- Checkbox del permiso -->
                                        <div class="form-check">
                                            <input class="form-check-input permission-checkbox" 
                                                   type="checkbox" 
                                                   name="permissions" 
                                                   value="{{ permiso.id }}"
                                                   id="perm-{{ permiso.id }}"
                                                   data-module="{{ modulo_key }}"
                                                   {% if permiso.seleccionado %}checked{% endif %}>
                                            <label class="form-check-label" for="perm-{{ permiso.id }}">
                                                <strong>{{ permiso.nombre }}</strong>
                                                {% if permiso.nivel_riesgo == 'critico' %}
                                                    <span class="badge bg-danger ms-2">Crítico</span>
                                                {% elif permiso.nivel_riesgo == 'alto' %}
                                                    <span class="badge bg-warning text-dark ms-2">Alto riesgo</span>
                                                {% endif %}
                                            </label>
                                        </div>
                                        
                                        <!-- Descripción -->
                                        <p class="text-muted small mt-2 mb-1">
                                            {{ permiso.descripcion }}
                                        </p>
                                        
                                        <!-- Ejemplo de uso -->
                                        {% if permiso.ejemplo %}
                                            <p class="text-info small mb-0">
                                                <i class="bi bi-lightbulb"></i> <em>{{ permiso.ejemplo }}</em>
                                            </p>
                                        {% endif %}
                                        
                                        <!-- Codename técnico (colapsable) -->
                                        <small class="text-secondary">
                                            <a data-bs-toggle="collapse" href="#code-{{ permiso.id }}">
                                                Ver código técnico
                                            </a>
                                            <div class="collapse" id="code-{{ permiso.id }}">
                                                <code>{{ permiso.codename }}</code>
                                            </div>
                                        </small>
                                    </div>
                                </div>
                            </div>
                        {% endfor %}
                    </div>
                </div>
            {% endfor %}
        </div>
        
        <!-- Botones de acción -->
        <div class="mt-4">
            <button type="submit" class="btn btn-primary">
                <i class="bi bi-save"></i> Guardar Cambios
            </button>
            <a href="{% url 'group_list' %}" class="btn btn-secondary">
                Cancelar
            </a>
            
            <!-- Contador de cambios pendientes -->
            <span class="ms-3 text-muted" id="changes-counter">
                Sin cambios pendientes
            </span>
        </div>
    </form>
</div>

<script>
// JavaScript para mejorar UX
document.addEventListener('DOMContentLoaded', function() {
    const checkboxes = document.querySelectorAll('.permission-checkbox');
    const initialState = new Set();
    
    // Guardar estado inicial
    checkboxes.forEach(cb => {
        if (cb.checked) initialState.add(cb.value);
    });
    
    // Contador de cambios
    function updateChangesCounter() {
        let changes = 0;
        checkboxes.forEach(cb => {
            const wasChecked = initialState.has(cb.value);
            const isChecked = cb.checked;
            if (wasChecked !== isChecked) changes++;
        });
        
        const counter = document.getElementById('changes-counter');
        if (changes > 0) {
            counter.textContent = `${changes} cambio(s) pendiente(s)`;
            counter.classList.add('text-warning', 'fw-bold');
        } else {
            counter.textContent = 'Sin cambios pendientes';
            counter.classList.remove('text-warning', 'fw-bold');
        }
    }
    
    checkboxes.forEach(cb => cb.addEventListener('change', updateChangesCounter));
    
    // Seleccionar/Deseleccionar todos de un módulo
    document.querySelectorAll('.select-all-module').forEach(btn => {
        btn.addEventListener('click', function() {
            const module = this.dataset.module;
            document.querySelectorAll(`.permission-checkbox[data-module="${module}"]`)
                .forEach(cb => cb.checked = true);
            updateChangesCounter();
        });
    });
    
    document.querySelectorAll('.deselect-all-module').forEach(btn => {
        btn.addEventListener('click', function() {
            const module = this.dataset.module;
            document.querySelectorAll(`.permission-checkbox[data-module="${module}"]`)
                .forEach(cb => cb.checked = false);
            updateChangesCounter();
        });
    });
});
</script>
{% endblock %}
Componente 3: Comando de Gestión para Inicializar Permisos
El admin NO crea permisos desde cero (eso sería peligroso), sino que selecciona entre permisos predefinidos. Cuando agregas funcionalidad nueva, ejecutas un comando que sincroniza los permisos.
python# roles/management/commands/sync_permissions.py
from django.core.management.base import BaseCommand
from django.contrib.auth.models import Permission
from django.contrib.contenttypes.models import ContentType
from roles.models import PermissionMetadata

class Command(BaseCommand):
    help = 'Sincroniza permisos personalizados y crea su metadata'

    def handle(self, *args, **kwargs):
        permisos_definidos = self.get_permisos_definidos()
        
        creados = 0
        actualizados = 0
        
        for permiso_def in permisos_definidos:
            # Crear o actualizar permiso
            content_type = ContentType.objects.get(
                app_label=permiso_def['app_label'],
                model=permiso_def['model']
            )
            
            permission, created = Permission.objects.get_or_create(
                codename=permiso_def['codename'],
                content_type=content_type,
                defaults={'name': permiso_def['name']}
            )
            
            # Crear o actualizar metadata
            metadata, meta_created = PermissionMetadata.objects.update_or_create(
                permission=permission,
                defaults={
                    'modulo': permiso_def['modulo'],
                    'descripcion_detallada': permiso_def['descripcion'],
                    'ejemplo_uso': permiso_def.get('ejemplo', ''),
                    'nivel_riesgo': permiso_def.get('nivel_riesgo', 'medio'),
                    'orden': permiso_def.get('orden', 0),
                }
            )
            
            if created:
                creados += 1
                self.stdout.write(self.style.SUCCESS(f'✓ Creado: {permission.name}'))
            else:
                actualizados += 1
                self.stdout.write(f'  Actualizado: {permission.name}')
        
        self.stdout.write(self.style.SUCCESS(f'\n✓ Sincronización completa: {creados} creados, {actualizados} actualizados'))

    def get_permisos_definidos(self):
        """
        Define todos los permisos personalizados del sistema.
        ESTE ES EL ÚNICO LUGAR donde se definen permisos en código.
        """
        return [
            # ============ CLIENTES ============
            {
                'app_label': 'clientes',
                'model': 'cliente',
                'codename': 'view_assigned_clientes',
                'name': 'Puede ver clientes asignados',
                'modulo': 'clientes',
                'descripcion': 'Permite ver únicamente los clientes que están asignados al usuario',
                'ejemplo': 'Un operador puede ver los datos de sus clientes asignados pero no de otros',
                'nivel_riesgo': 'bajo',
                'orden': 1,
            },
            {
                'app_label': 'clientes',
                'model': 'cliente',
                'codename': 'view_all_clientes',
                'name': 'Puede ver todos los clientes',
                'modulo': 'clientes',
                'descripcion': 'Permite ver TODOS los clientes del sistema sin restricción de asignación',
                'ejemplo': 'Un administrador puede ver cualquier cliente del sistema',
                'nivel_riesgo': 'medio',
                'orden': 2,
            },
            {
                'app_label': 'clientes',
                'model': 'cliente',
                'codename': 'manage_cliente_assignment',
                'name': 'Puede asignar clientes a operadores',
                'modulo': 'clientes',
                'descripcion': 'Permite asociar y desasociar clientes con operadores',
                'ejemplo': 'Un supervisor puede asignar nuevos clientes a sus operadores',
                'nivel_riesgo': 'alto',
                'orden': 3,
            },
            {
                'app_label': 'clientes',
                'model': 'cliente',
                'codename': 'manage_limits',
                'name': 'Puede modificar límites diarios/mensuales',
                'modulo': 'clientes',
                'descripcion': 'Permite crear y modificar los límites de operación diarios y mensuales',
                'ejemplo': 'Un administrador puede aumentar el límite diario de operaciones',
                'nivel_riesgo': 'critico',
                'orden': 4,
            },
            
            # ============ MEDIOS DE PAGO ============
            {
                'app_label': 'clientes',
                'model': 'clientemediopago',
                'codename': 'manage_medios_pago',
                'name': 'Puede gestionar medios de pago',
                'modulo': 'medios_pago',
                'descripcion': 'Permite crear, editar y eliminar medios de pago de clientes',
                'ejemplo': 'Un operador puede agregar una nueva tarjeta de crédito a su cliente',
                'nivel_riesgo': 'medio',
                'orden': 1,
            },
            {
                'app_label': 'clientes',
                'model': 'clientemediopago',
                'codename': 'view_medios_pago',
                'name': 'Puede ver medios de pago',
                'modulo': 'medios_pago',
                'descripcion': 'Permite visualizar los medios de pago configurados',
                'ejemplo': 'Un analista puede consultar qué medios de pago tiene un cliente',
                'nivel_riesgo': 'bajo',
                'orden': 2,
            },
            
            # ============ DIVISAS ============
            {
                'app_label': 'divisas',
                'model': 'divisa',
                'codename': 'realizar_operaciones',
                'name': 'Puede realizar operaciones de compra/venta',
                'modulo': 'divisas',
                'descripcion': 'Permite ejecutar operaciones de compra y venta de divisas',
                'ejemplo': 'Un operador puede procesar la venta de USD de un cliente',
                'nivel_riesgo': 'alto',
                'orden': 1,
            },
            {
                'app_label': 'divisas',
                'model': 'tasacambio',
                'codename': 'configure_tasas',
                'name': 'Puede configurar tasas de cambio',
                'modulo': 'divisas',
                'descripcion': 'Permite modificar las tasas de cambio y cotizaciones',
                'ejemplo': 'Un administrador puede actualizar la tasa de compra del dólar',
                'nivel_riesgo': 'critico',
                'orden': 2,
            },
            
            # ============ TRANSACCIONES ============
            {
                'app_label': 'transacciones',
                'model': 'transaccion',
                'codename': 'view_transacciones',
                'name': 'Puede ver transacciones',
                'modulo': 'transacciones',
                'descripcion': 'Permite visualizar el historial de transacciones',
                'ejemplo': 'Un analista puede consultar las transacciones del día',
                'nivel_riesgo': 'bajo',
                'orden': 1,
            },
            {
                'app_label': 'transacciones',
                'model': 'transaccion',
                'codename': 'export_reportes',
                'name': 'Puede exportar reportes',
                'modulo': 'reportes',
                'descripcion': 'Permite exportar datos y generar reportes en CSV/Excel',
                'ejemplo': 'Un contador puede exportar todas las transacciones del mes',
                'nivel_riesgo': 'medio',
                'orden': 1,
            },
            
            # ============ USUARIOS ============
            {
                'app_label': 'users',
                'model': 'customuser',
                'codename': 'manage_operators',
                'name': 'Puede gestionar operadores',
                'modulo': 'usuarios',
                'descripcion': 'Permite crear, editar y desactivar cuentas de operadores',
                'ejemplo': 'Un supervisor puede crear una cuenta para un nuevo operador',
                'nivel_riesgo': 'critico',
                'orden': 1,
            },
        ]
Uso del comando
bash# Después de agregar nueva funcionalidad
python manage.py sync_permissions

# El admin luego va a la UI y asigna esos permisos a los roles que correspondan
3. Flujo Completo: Admin Gestiona Permisos
Escenario: Agregar nueva funcionalidad "Aprobar Transacciones"
PASO 1: Desarrollador agrega funcionalidad
python# Agregar a get_permisos_definidos() en sync_permissions.py
{
    'app_label': 'transacciones',
    'model': 'transaccion',
    'codename': 'approve_transactions',
    'name': 'Puede aprobar transacciones',
    'modulo': 'transacciones',
    'descripcion': 'Permite aprobar o rechazar transacciones pendientes',
    'ejemplo': 'Un supervisor revisa y aprueba transacciones de alto monto',
    'nivel_riesgo': 'alto',
    'orden': 2,
}
PASO 2: Ejecutar comando
bashpython manage.py sync_permissions
# ✓ Creado: Puede aprobar transacciones
PASO 3: Admin asigna permiso desde UI

Admin va a /roles/groups/ → Selecciona rol "supervisor"
Ve pestaña "Transacciones"
Encuentra nuevo permiso "Puede aprobar transacciones" con su descripción
Marca checkbox
Guarda cambios

PASO 4: Verificación automática en código
python# transacciones/views.py
@require_permission('transacciones.approve_transactions')
def aprobar_transaccion(request, transaccion_id):
    # Solo usuarios con el permiso pueden acceder
    ...
4. Ventajas de este Sistema

Admin tiene control total: Decide qué rol tiene qué permisos sin tocar código
Desarrollador define capacidades: Solo especifica QUÉ permisos existen
Autodocumentado: Cada permiso tiene descripción y ejemplo
Auditable: Log de cambios de permisos
Escalable: Agregar funcionalidad = 1 entrada en comando + ejecutar sync
Seguro: No se crean permisos arbitrarios, solo los predefinidos



Análisis Crítico de Escalabilidad y Flujo de Trabajo
1. Evaluación Realista del Modelo
Escalabilidad: SÍ, pero con advertencias
Ventajas reales:

Agregar funcionalidad = 1 entrada en el diccionario + ejecutar comando
No tocas vistas existentes
Admin gestiona permisos sin desarrollador

Problemas potenciales que debes conocer:

El archivo sync_permissions.py crecerá mucho: Con 50+ funcionalidades tendrás 200+ líneas solo de definiciones. Solución: dividir por módulos.
Coordinación de equipo: Si 3 desarrolladores agregan funcionalidades simultáneamente, pueden tener conflictos en el mismo archivo.
Testing manual necesario: Cada nuevo permiso requiere que alguien lo pruebe con diferentes roles.

2. Caso Práctico: "Gráfico en Tiempo Real"
Flujo COMPLETO desde desarrollo hasta producción
PASO 1: Desarrollador implementa funcionalidad
python# divisas/views.py (NUEVA VISTA)
from django.contrib.auth.decorators import login_required, permission_required
from django.http import JsonResponse

@login_required
@permission_required('divisas.view_realtime_charts', raise_exception=True)
def grafico_tiempo_real(request):
    """
    Vista que retorna datos para gráfico de compras/ventas en tiempo real
    """
    # Lógica para obtener datos
    datos = {
        'compras': [...],
        'ventas': [...],
        'timestamp': timezone.now()
    }
    return JsonResponse(datos)
python# divisas/urls.py (NUEVA RUTA)
urlpatterns = [
    # ... rutas existentes
    path('dashboard/grafico-realtime/', grafico_tiempo_real, name='grafico_realtime'),
]
html<!-- templates/dashboard_analista.html (NUEVO COMPONENTE) -->
<div class="card">
    <div class="card-header">
        <h5>Operaciones en Tiempo Real</h5>
    </div>
    <div class="card-body">
        <canvas id="realtime-chart"></canvas>
    </div>
</div>

<script>
// Código para actualizar gráfico cada 5 segundos
setInterval(function() {
    fetch('/divisas/dashboard/grafico-realtime/')
        .then(response => response.json())
        .then(data => updateChart(data));
}, 5000);
</script>
PASO 2: Desarrollador agrega permiso al comando
python# roles/management/commands/sync_permissions.py

def get_permisos_definidos(self):
    return [
        # ... permisos existentes ...
        
        # NUEVO PERMISO AGREGADO
        {
            'app_label': 'divisas',
            'model': 'divisa',
            'codename': 'view_realtime_charts',
            'name': 'Puede ver gráficos en tiempo real',
            'modulo': 'reportes',  # Lo categorizamos en "reportes"
            'descripcion': 'Permite visualizar gráficos dinámicos de compras/ventas actualizados en tiempo real',
            'ejemplo': 'Un analista puede monitorear el volumen de operaciones del día en un dashboard actualizado automáticamente',
            'nivel_riesgo': 'bajo',  # Solo lectura
            'orden': 5,
        },
    ]
PASO 3: Ejecutar sincronización
bash# En desarrollo
python manage.py sync_permissions

# Salida:
# ✓ Creado: Puede ver gráficos en tiempo real
# ✓ Sincronización completa: 1 creados, 42 actualizados
PASO 4: Testing inicial (ROL DE PRUEBA)
Aquí es donde respondes a tu pregunta sobre "¿cómo el equipo ve las funcionalidades?"
Opción A: Crear rol "Desarrollador/QA"
python# Puedes crear un comando adicional para setup de testing
# roles/management/commands/setup_test_roles.py

from django.core.management.base import BaseCommand
from django.contrib.auth.models import Group, Permission

class Command(BaseCommand):
    help = 'Crea roles de prueba con todos los permisos'

    def handle(self, *args, **kwargs):
        # Crear grupo de prueba
        qa_group, created = Group.objects.get_or_create(name='QA_Testing')
        
        # Asignar TODOS los permisos
        all_permissions = Permission.objects.filter(
            metadata__isnull=False  # Solo permisos con metadata
        )
        qa_group.permissions.set(all_permissions)
        
        self.stdout.write(
            self.style.SUCCESS(
                f'✓ Rol QA_Testing creado con {all_permissions.count()} permisos'
            )
        )
bashpython manage.py setup_test_roles

# Crear usuario de prueba
python manage.py shell
>>> from users.models import CustomUser
>>> qa_user = CustomUser.objects.create_user(
...     email='qa@test.com',
...     username='qa_tester',
...     password='testing123'
... )
>>> qa_user.groups.add(Group.objects.get(name='QA_Testing'))
Opción B: Usar superusuario (más simple)
Los superusuarios tienen acceso a TODO sin verificar permisos. Útil para testing rápido.
PASO 5: Admin asigna permiso a roles productivos

Admin ingresa al sistema → /roles/groups/
Selecciona rol "analista"
Va a pestaña "Reportes"
Ve el nuevo permiso: "Puede ver gráficos en tiempo real"

Descripción completa visible
Ejemplo de uso visible
Nivel de riesgo: "Bajo"


Marca el checkbox
Guarda cambios

Captura de lo que ve el admin:
┌─────────────────────────────────────────────────────────┐
│ Módulo: Reportes                                        │
├─────────────────────────────────────────────────────────┤
│                                                          │
│ ☐ Puede exportar reportes                              │
│   Permite exportar datos en CSV/Excel                   │
│   Ejemplo: Un contador exporta transacciones del mes    │
│   [Medio riesgo]                                        │
│                                                          │
│ ☑ Puede ver gráficos en tiempo real         ← NUEVO    │
│   Permite visualizar gráficos dinámicos de compras/     │
│   ventas actualizados en tiempo real                    │
│   Ejemplo: Un analista monitorea operaciones del día    │
│   [Bajo riesgo]                                         │
│                                                          │
└─────────────────────────────────────────────────────────┘
PASO 6: Verificación automática en producción
Usuario "analista@empresa.com" inicia sesión:
python# Django automáticamente verifica:
# 1. ¿Usuario autenticado? ✓
# 2. ¿Tiene permiso 'divisas.view_realtime_charts'? ✓
# 3. Permite acceso a /divisas/dashboard/grafico-realtime/
Usuario "operador@empresa.com" intenta acceder:
python# Django automáticamente verifica:
# 1. ¿Usuario autenticado? ✓
# 2. ¿Tiene permiso 'divisas.view_realtime_charts'? ✗
# 3. Retorna 403 Forbidden
3. Flujo de Trabajo en Equipo (Diagrama Completo)
DESARROLLADOR A                DESARROLLADOR B              ADMIN
     │                              │                         │
     │ Implementa                   │ Implementa              │
     │ "Gráfico realtime"           │ "Exportar Excel"        │
     │                              │                         │
     ▼                              ▼                         │
┌─────────────────┐          ┌─────────────────┐            │
│ Agrega permiso  │          │ Agrega permiso  │            │
│ en sync_perms   │          │ en sync_perms   │            │
└─────────────────┘          └─────────────────┘            │
     │                              │                         │
     └──────────────┬───────────────┘                         │
                    ▼                                         │
            ┌──────────────────┐                              │
            │  GIT MERGE        │                              │
            │  (puede haber     │                              │
            │   conflictos)     │                              │
            └──────────────────┘                              │
                    │                                         │
                    ▼                                         │
            ┌──────────────────┐                              │
            │ python manage.py │                              │
            │ sync_permissions │                              │
            └──────────────────┘                              │
                    │                                         │
                    │ Crea 2 permisos en BD                   │
                    │                                         │
                    ▼                                         │
            ┌──────────────────┐                              │
            │ Usuario QA prueba│                              │
            │ ambas funciones  │                              │
            └──────────────────┘                              │
                    │                                         │
                    │ Testing OK                              │
                    │                                         │
                    ▼                                         │
            ┌──────────────────┐                              │
            │ Deploy producción│                              │
            └──────────────────┘                              │
                    │                                         │
                    │ Notificación al admin                   │
                    │                                         │
                    └─────────────────────────────────────────▶
                                                              │
                                            ┌─────────────────▼────────┐
                                            │ Admin ve nuevos permisos │
                                            │ en interfaz web          │
                                            └─────────────────┬────────┘
                                                              │
                                            ┌─────────────────▼────────┐
                                            │ Asigna a rol "analista"  │
                                            │ y rol "supervisor"       │
                                            └─────────────────┬────────┘
                                                              │
                                            ┌─────────────────▼────────┐
                                            │ Usuarios con esos roles  │
                                            │ ven nuevas funciones     │
                                            └──────────────────────────┘
4. Gestión de Conflictos Git
Este es un problema REAL que encontrarás:
Escenario: Dev A y Dev B agregan permisos simultáneamente
python# Dev A agrega (línea 150):
{
    'codename': 'view_realtime_charts',
    ...
},

# Dev B agrega (línea 150):
{
    'codename': 'export_excel_reports',
    ...
},
Solución 1: Estructura modular
python# roles/management/commands/sync_permissions.py
from .permissions_definitions import (
    PERMISOS_CLIENTES,
    PERMISOS_DIVISAS,
    PERMISOS_TRANSACCIONES,
    PERMISOS_REPORTES,
)

class Command(BaseCommand):
    def get_permisos_definidos(self):
        return (
            PERMISOS_CLIENTES +
            PERMISOS_DIVISAS +
            PERMISOS_TRANSACCIONES +
            PERMISOS_REPORTES
        )
python# roles/management/commands/permissions_definitions/divisas.py
PERMISOS_DIVISAS = [
    {
        'codename': 'realizar_operaciones',
        ...
    },
    {
        'codename': 'view_realtime_charts',  # Dev A trabaja aquí
        ...
    },
]
python# roles/management/commands/permissions_definitions/reportes.py
PERMISOS_REPORTES = [
    {
        'codename': 'export_excel_reports',  # Dev B trabaja aquí
        ...
    },
]
Ventaja: Menos conflictos, cada dev trabaja en su archivo.
5. Testing y Visibilidad de Funcionalidades
Problema Real: "No sé si funciona porque no tengo permisos"
Solución A: Modo Debug con bypass temporal
python# settings.py
DEBUG_BYPASS_PERMISSIONS = DEBUG and os.getenv('BYPASS_PERMS', 'False') == 'True'
python# clientes/decorators.py
def require_permission(permission):
    def decorator(view_func):
        @wraps(view_func)
        def wrapper(request, *args, **kwargs):
            # BYPASS SOLO EN DESARROLLO
            if settings.DEBUG_BYPASS_PERMISSIONS:
                logger.warning(f'⚠️  BYPASS: Permiso {permission} ignorado (modo dev)')
                return view_func(request, *args, **kwargs)
            
            # Verificación normal
            if not request.user.has_perm(permission):
                raise PermissionDenied
            
            return view_func(request, *args, **kwargs)
        return wrapper
    return decorator
Solución B: Panel de testing en template
html<!-- templates/partials/dev_toolbar.html -->
{% if debug %}
<div class="dev-toolbar">
    <strong>Modo Desarrollo</strong>
    Usuario: {{ user.email }}
    Grupo: {{ user.groups.first.name }}
    
    <details>
        <summary>Permisos actuales ({{ user.get_all_permissions|length }})</summary>
        <ul>
        {% for perm in user.get_all_permissions %}
            <li><code>{{ perm }}</code></li>
        {% endfor %}
        </ul>
    </details>
    
    <a href="{% url 'switch_to_qa_role' %}" class="btn btn-sm btn-warning">
        Cambiar a rol QA (todos los permisos)
    </a>
</div>
{% endif %}
Solución C: Comando para imprimir matriz de permisos
python# roles/management/commands/show_permission_matrix.py
from django.core.management.base import BaseCommand
from django.contrib.auth.models import Group
from tabulate import tabulate  # pip install tabulate

class Command(BaseCommand):
    help = 'Muestra matriz de permisos por rol'

    def handle(self, *args, **kwargs):
        roles = Group.objects.all()
        permisos = Permission.objects.filter(metadata__isnull=False)
        
        # Crear matriz
        headers = ['Permiso'] + [role.name for role in roles]
        rows = []
        
        for permiso in permisos:
            row = [permiso.name]
            for role in roles:
                tiene = '✓' if permiso in role.permissions.all() else '✗'
                row.append(tiene)
            rows.append(row)
        
        print(tabulate(rows, headers=headers, tablefmt='grid'))
bashpython manage.py show_permission_matrix

# Salida:
┌────────────────────────────────┬───────┬──────────┬─────────┐
│ Permiso                        │ admin │ analista │ operador│
├────────────────────────────────┼───────┼──────────┼─────────┤
│ Ver clientes asignados         │   ✓   │    ✗     │    ✓    │
│ Ver todos los clientes         │   ✓   │    ✗     │    ✗    │
│ Ver gráficos en tiempo real    │   ✓   │    ✓     │    ✗    │
│ Realizar operaciones           │   ✓   │    ✗     │    ✓    │
└────────────────────────────────┴───────┴──────────┴─────────┘
6. Respuesta Directa a tus Preguntas
"¿Es escalable?"
Sí, pero necesitas:

Dividir definiciones de permisos por módulo (evitar archivo gigante)
Documentar convención de nombres (view_, manage_, export_)
Mantener matriz de permisos actualizada

"¿Cómo el equipo ve las funcionalidades?"
Tres opciones:

Rol QA con todos los permisos
Superusuario (acceso absoluto)
Bypass temporal en desarrollo (más rápido pero menos seguro)

"¿Agregar permisos solo en sync_permissions.py?"
Sí, ese es el ÚNICO lugar donde defines permisos nuevos. Ventajas:

Un solo lugar donde buscar
Fácil hacer code review
Fácil revertir cambios

Alternativa mejor: Dividir en múltiples archivos por módulo.


